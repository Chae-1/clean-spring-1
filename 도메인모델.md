# Splearn 도메인 모델

## 도메인 모델 만들기
1. 듣고 배우기
2. '중요한 것'을 찾기 (개념 식별)
3. '연결 고리' 찾기 (관계 정의)
4. '것들' 설명하기 (속성 및 기본 행위 명시)
5. 그려보기 (시각화)
6. 이야기 하고 다듬기 (반복)

## Splearn 도메인
- 스프런은 회원이 강의를 수강하는 온라인 서비스이다.
- 스프런은 스프링 프레임워크의 철학을 바탕으로 개발되고 운영되며 발전하는 학습 생태계를 목표로 한다.
  이 생테계를 구성하는 핵심 구성 요소는 학습(성장)하는 회원이다.
    - 그래서 이름이 Spring + Learner = Splearn
    - 유사한 이름으로 인프런이 있다.
- 스프런에서 활동하기 위해서는 회원으로 가입해야 한다.
    - 다만, 회원이 되기 전에는 스프링에 대한 소개와 강의 정보를 살펴볼 수 있다.
    - 강의를 수강하기 위해서는 가입을 완료하고 활동 가능한 회원이 되어야 한다.
    - 가입 신청을 한 뒤 정해진 요건을 충족하면 가입이 완료된다.
- 원하는 회원은 자신이 가진 지식과 경험을 강의라는 형태로 다른 회원에게 제공하는 강사가 될 수도 있다.
    - 회원이 최초로 강사가 되려면 강사 신청과 승인 과정을 거치도록 한다.
    - 승인된 강사는 강의를 생성하고 검수를 거쳐 강의를 공개할 수 있다.
    - 공개된 강의는 회원에게 노출되고, 회원은 이 강의를 수강할 수 있다.
- 수강은 강의를 학습하는 것을 말한다. "내가 수강한 강의는 a이다. 나는 b 강의를 수강중이다."
    - 수강을 위해서는 먼저 수강 신청이 필요하다.
    - 수강 신청은 강의의 수강 요건에 따라서 신청을 해야 하고 이후 추가 절차가 요구될 수 있다.
    - 일부 강의는 수강 신청과 동시에 수강이 가능하다.
    - 강사는 강의 수강 기간의 제한을 둘 수 있다.
- 강의는 영상, 문서와 같은 컨텐츠를 가진 하나의 수업으로 구성된다.
    - 수업의 갯수가 많을 수 있다. 그래서 수업은 다시 섹션으로 구분된다.
    - 하나의 강의는 여러 개의 섹션과 각 섹센에 속한 수업으로 구성된다.
    - 수업과 섹션은 학습 순서를 가진다.
    - 학습 진도는 매 수업 단위로 기록된다.
    - 강의의 모든 수업의 학습을 마치고 수업 진도가 100%에 도달하면 강의 수강을 완료한 것이다.

## 도메인 모델

### 회원(Member)
_Entity_
#### 속성
- `email`: 이메일 - ID
- `nickname`: 닉네임 
- `passwordHash`: 비밀번호
- `status`: `MemberStatus` 회원 상태
#### 행위
- `static create()`: 회원 생성: email, nickname, passwordHash, status
- `activate`: 가입을 완료시킨다
- `deactivate`: 탈퇴시킨다
- `verifyPassword()`: 비밀번호를 검증한다
#### 규칙
- 회원 생성후 상태는 가입 대기
- 일정 조건을 만족하면 가입 완료가 된다.
- 가입 대기 상태에서만 가입 완료가 될 수 있다.
- 가입 완료 상태에서는 탈퇴할 수 있다.
- 회원의 비밀번호는 해시를 만들어서 저장한다.

### 회원 상태(MemberStatus)
_Enum_
#### 상수
- `PENDING`: 가입 대기
- `ACTIVE`: 가입 완료
- `DEACTIVATED`: 탈퇴

### 비밀번호 인코더(PasswordEncoder)
_Domain Service_
#### 행위
- `encode()`: 비밀번호 암호화하기
- `matches()`: 비밀번호 일치하는지 확인

### 강사

### 강의

### 수업

### 섹션

### 수강

### 진도


### 값 객체(Value Object)
- 도메인 모델에서 식별자가 필요하지 않고 속성/값으로만 구별되는 오브젝트
- 엔터티가 너무 많은 책임을 가지는 것을 방지하고 특정 속성 관련 행위를 분리해서 엔터티를 더 집중된 상태로 유지하게 한다.
- 원시 타입보다는 도메인 개념을 더 명시적으로 나타내서 모델의 명확성을 높인다.
- 생성 이후에 상태가 변하지 않고 변경이 필요하면 새로운 객체로 교체한다.
- 풍부한 기능을 가진다.
- 자체 유효성 검사도 가능하다.

### 원시 타입을 객체로 교체 - 리팩터링
- 원시 타입의 남용을 개선하고 코드의 명시성과 안정성을 높이는 리팩터링 방법
- 값 객체는 도메인 모델의 핵심 구성 요소로 값 자체의 의미를 담아내고 불변성, 동등성 등의 도메인 로직을 포함하여 설계하는 방식.

### 두가지 스타일
- 단순 도메인 모델
  - DB 설계와 유사, 테이블에 대해 하나의 도메인 오브젝트
- 풍성한 도메인 모델
  - 상속, 전략, GoF 디자인 패턴, 연관 관계 복잡한 로직에 적합하지만, DB 매핑이 어려울 수 있다.

### 도메인 로직의 API 개발
- Application Programming Interface
- 도메인 모델 패턴은 트랜잭션 스크립트 처럼 작업 단위의 절차형 API를 만들기가 어렵다.
- 도메인 로직의 명확한 작업 단위 API를 제공하는 **애플리케이션 서비스**가 필요
  - 스프링에서 말하는 서비스는 작업 흐름을 나열해 놓은 트랜잭션 스크립트 패턴이 적용된 것이다.

## 헥사고날 아키텍처
### 아키텍처
- 시스템의 **기본적인 구조**를 정의한다.
- 시스템의 중요한 **품질 속성에 큰 영향**을 미친다.
- **설계 결정의 기반**이 되는 핵심적인 개념이다.
- 기본 **구성 요소**와 **상호 관계, 제약 조건, 원칙** 등을 포함한다.

### Layered Architecture
- 서브 시스템을 계층으로 구조화 하는 아키텍처 스타일이다.
- 계층은 **사용 관계**로 연결된다.
- 사용 관계는 일반적으로 **단방향이어야 한다**는 핵심 제약이 있다.
  - 상위 계층이 하위 계층의 서비스를 사용하는 하향식 흐름을 가진다.
- 각 계층이 하위 계층의 내부 작동 방식을 알지 못하고 **제한된 인터페이스만 사용**하도록 한다
  - 계층 격리 Layers of Isolation
  - 서비스 빈들에 대한 내용 (인터페이스를 정의하느냐, 구체 클래스를 그대로 사용하느냐)
  - 어떤 레이어의 **변경**이 다른 레이어의 컴포넌트에게 가능한 **영향을 주지 않도록** 해야한다.

### 3계층 아키텍처
- UI(Presentation)
  - 사용자로부터 요청을 받고 응답하는 역할을 담당하는 레이어
- Application Service
  - 순수 도메인 로직으로만으로는 부족하여, 다른 레이어에 API를 제공하기 위해서 도메인의 기능을 사용하는 특정 레이어를 두어야한다.
- Domain(Business Logic) 
  - 사용자들의 관심사를 담은 레이어
  - Transaction Script
  - Domain Model
- Data(Persistence) -> Infra
  - 데이터 저장소와의 상호작용을 담당하는 레이어
  - 다양한 종류의 외부 서비스를 사용하게 되면서, 인프라 계층이라고 부르기도 한다.
### 헥사고날 아키텍처의 사실과 오해
